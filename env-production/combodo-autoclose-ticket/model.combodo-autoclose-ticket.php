						<?php
//
// File generated by ... on the 2018-07-13T16:42:54+0200
// Please do not edit manually
//

/**
 * Classes and menus for combodo-autoclose-ticket (version 2.0.1)
 *
 * @author      iTop compiler
 * @license     http://opensource.org/licenses/AGPL-3.0
 */



class ClosingRule extends cmdbAbstractObject
{
	public static function Init()
	{
		$aParams = array
		(
			'category' => 'bizmodel,searchable',
			'key_type' => 'autoincrement',
			'name_attcode' => array('name'),
			'state_attcode' => '',
			'reconc_keys' => array('target_class'),
			'db_table' => 'closingrule',
			'db_key_field' => 'id',
			'db_finalclass_field' => '',
		);
		MetaModel::Init_Params($aParams);
		MetaModel::Init_InheritAttributes();
		MetaModel::Init_AddAttribute(new AttributeString("name", array("allowed_values"=>null, "sql"=>'name', "default_value"=>'', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("target_class", array("allowed_values"=>null, "sql"=>'target_class', "default_value"=>'', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("stimulus_code", array("allowed_values"=>null, "sql"=>'stimulus_code', "default_value"=>'', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("history_entry", array("allowed_values"=>null, "sql"=>'history_entry', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("status", array("allowed_values"=>new ValueSetEnum("active,inactive"), "display_style"=>'list', "sql"=>'status', "default_value"=>'active', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("type", array("allowed_values"=>new ValueSetEnum("simple,advanced"), "display_style"=>'list', "sql"=>'type', "default_value"=>'simple', "is_null_allowed"=>false, "depends_on"=>array('pre_closing_state_code', 'date_to_check_att', 'autoclose_delay', 'oql_scope'), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("pre_closing_state_code", array("allowed_values"=>null, "sql"=>'pre_closing_state_code', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("date_to_check_att", array("allowed_values"=>null, "sql"=>'date_to_check_att', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeInteger("autoclose_delay", array("allowed_values"=>null, "sql"=>'autoclose_delay', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeOQL("oql_scope", array("allowed_values"=>null, "sql"=>'oql_scope', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));



		MetaModel::Init_SetZListItems('details', array (
  'col:col0' => 
  array (
    'fieldset:ClosingRule:general' => 
    array (
      0 => 'name',
      1 => 'target_class',
      2 => 'stimulus_code',
      3 => 'history_entry',
      4 => 'status',
      5 => 'type',
    ),
  ),
  'col:col1' => 
  array (
    'fieldset:ClosingRule:simple' => 
    array (
      0 => 'pre_closing_state_code',
      1 => 'date_to_check_att',
      2 => 'autoclose_delay',
    ),
  ),
  'col:col2' => 
  array (
    'fieldset:ClosingRule:advanced' => 
    array (
      0 => 'oql_scope',
    ),
  ),
));
		MetaModel::Init_SetZListItems('standard_search', array (
  0 => 'name',
  1 => 'target_class',
  2 => 'status',
  3 => 'type',
  4 => 'stimulus_code',
  5 => 'history_entry',
  6 => 'pre_closing_state_code',
  7 => 'date_to_check_att',
  8 => 'autoclose_delay',
  9 => 'oql_scope',
));
		MetaModel::Init_SetZListItems('list', array (
  0 => 'target_class',
  1 => 'name',
  2 => 'stimulus_code',
  3 => 'status',
  4 => 'type',
));

	}



	public function GetInitialStateAttributeFlags($sAttCode, &$aReasons = array())
	{
		if ($sAttCode == 'type')
		{
		    return OPT_ATT_READONLY;
		}
		return parent::GetInitialStateAttributeFlags($sAttCode, $aReasons);
	}



	public function GetAttributeFlags($sAttCode, &$aReasons = array(), $sTargetState = '')
	{
		if ($sAttCode == 'type')
		{
		    return OPT_ATT_READONLY;
		}
		return parent::GetAttributeFlags($sAttCode, $aReasons, $sTargetState);
	}



	public function ComputeValues()
	{
		// Compute the type of the rule
		$oAttDef = MetaModel::GetAttributeDef(get_class($this), 'oql_scope');
		$sType = ($oAttDef->IsNull($this->Get('oql_scope'))) ? 'simple' : 'advanced';

		$this->Set('type', $sType);

		return parent::ComputeValues();
	}


    public function DoCheckToWrite()
	{
		parent::DoCheckToWrite();

		// Checking class / attributes consistency with Datamodel
		$sClass = $this->Get('target_class');
		$sStimulusCode = $this->Get('stimulus_code');
		$sPreClosingStateCode = $this->Get('pre_closing_state_code');
		$sDateToCheckAttCode = $this->Get('date_to_check_att');
		$sOqlScope = $this->Get('oql_scope');
		// - Class
		if(!MetaModel::IsValidClass($sClass))
		{
		    $this->m_aCheckIssues[] = Dict::Format('Class:ClosingRule/Error:ClassNotValid', $sClass);
		}
		// - Preclosing state code attribute
		$aStates = MetaModel::EnumStates($sClass);
		if(!empty($sPreClosingStateCode) && !array_key_exists($sPreClosingStateCode, $aStates))
		{
			$this->m_aCheckIssues[] = Dict::Format('Class:ClosingRule/Error:StateNotValid', $sClass, $sPreClosingStateCode);
		}
		// - Date to check attribute
		if(!empty($sDateToCheckAttCode))
		{
            if(!MetaModel::IsValidAttCode($sClass, $sDateToCheckAttCode))
            {
                $this->m_aCheckIssues[] = Dict::Format('Class:ClosingRule/Error:AttributeNotValid', $sClass, $sDateToCheckAttCode);
            }
            else
            {
                $oAttDef = MetaModel::GetAttributeDef($sClass, $sDateToCheckAttCode);
                if(($oAttDef instanceof AttributeDateTime) === false)
                {
                    $this->m_aCheckIssues[] = Dict::Format('Class:ClosingRule/Error:AttributeMustBeDate', $sClass, $sDateToCheckAttCode);
                }
            }
        }

		// Checking option consistency
		// - At least one option must be filled (either simple or advanced)
		$bNoOptionFilled = true;
		$aOptionAttCodes = array('pre_closing_state_code', 'date_to_check_att', 'autoclose_delay', 'oql_scope');
		foreach($aOptionAttCodes as $sOptionAttCode)
		{
			$oAttDef = MetaModel::GetAttributeDef(get_class($this), $sOptionAttCode);
			$value = $this->Get($sOptionAttCode);
			if(!$oAttDef->IsNull($value))
			{
				$bNoOptionFilled = false;
				break;
			}
		}

		if($bNoOptionFilled)
		{
			$this->m_aCheckIssues[] = Dict::Format('Class:ClosingRule/Error:NoOptionFilled');
		}
		// - Checking that option 1 is valid if selected
		elseif(empty($sOqlScope))
		{
			$bOptionOneValid = true;

			// Removing OQL attribute as we only test option 1 attributes
			array_pop($aOptionAttCodes);
			foreach($aOptionAttCodes as $sOptionAttCode)
			{
				$oAttDef = MetaModel::GetAttributeDef(get_class($this), $sOptionAttCode);
				$value = $this->Get($sOptionAttCode);
				if($oAttDef->IsNull($value))
				{
					$bOptionOneValid = false;
					break;
				}
			}

			if(!$bOptionOneValid)
			{
				$this->m_aCheckIssues[] = Dict::Format('Class:ClosingRule/Error:OptionOneMissingField');
			}
			// Checking that stimulus is valid for defined state (cannot be checked for an OQL as we don't know in which state will be the returned objects.
			else
			{
				$aStimuli = MetaModel::EnumStimuli($sClass);
				if(!array_key_exists($sStimulusCode, $aStimuli))
				{
					$this->m_aCheckIssues[] = Dict::Format('Class:ClosingRule/Error:StimulusNotValid', $sClass, $sStimulusCode);
				}
			}
		}
		// - Checking that option 2 OQL is about the right class
		elseif(!empty($sOqlScope))
		{
		    try
		    {
		        $oSearch = DBObjectSearch::FromOQL($sOqlScope);
		        $sOqlClass = $oSearch->GetClass();
			    if($sOqlClass !== $sClass)
			    {
				    $this->m_aCheckIssues[] = Dict::Format('Class:StateRule/Error:OQLClassDontMatch', $sClass, $sOqlClass);
			    }
		    }
		    catch(Exception $e)
		    {
		        $this->m_aCheckIssues[] = Dict::Format('Class:StateRule/Error:OQLNotValid', $e->getMessage());
		    }
		}

		// Checking that there not already a closing rule for this class
		$oSearch = DBObjectSearch::FromOQL('SELECT ClosingRule WHERE target_class = :target_class AND id != :id');
		$oSet = new DBObjectSet($oSearch, array(), array('target_class' => $sClass, 'id' => $this->GetKey()));
		if($oSet->Count() > 0)
		{
			$this->m_aCheckIssues[] = Dict::Format('Class:ClosingRule/Error:ExistingRuleForClass', $sClass);
		}
	}


	/**
    * @return DBObjectSearch
    */
    public function GetFilter()
	{
		if($this->Get('type') === 'advanced')
		{
		    $oSearch = DBObjectSearch::FromOQL($this->Get('oql_scope'));

            // Restrict OQL to states in which the stimulus is available
			if ($this->Get('type') === 'advanced')
			{
				$sClass = $this->Get('target_class');
				$aAvailableStatesCodes = $this->GetAvailableStatesForStimulus($sClass, $this->Get('stimulus_code'));

				$oSearch->AddConditionExpression(
					new BinaryExpression(
						new FieldExpression(MetaModel::GetStateAttributeCode($sClass), $oSearch->GetClassAlias()),
						'IN',
						ListExpression::FromScalars($aAvailableStatesCodes)
					)
				);
			}
        }
        else
        {
            $sClass = $this->Get('target_class');
            $sStateAttCode = MetaModel::GetStateAttributeCode($sClass);
            $sDateAttCode = $this->Get('date_to_check_att');

            $oSearch = DBObjectSearch::FromOQL('SELECT '.$sClass.' WHERE '.$sStateAttCode.' = :pre_closing_state_code AND '.$sDateAttCode.' <= DATE_SUB(NOW(), INTERVAL :autoclose_delay DAY)');
            $oSearch->SetInternalParams(
            	array(
            		'pre_closing_state_code' => $this->Get('pre_closing_state_code'),
		            'autoclose_delay' => $this->Get('autoclose_delay'),
	            )
            );
        }

        return $oSearch;
	}


	/**
	 * @param \WebPage $oPage
	 * @param bool $bEditMode
	 */
	public function DisplayBareRelations(WebPage $oPage, $bEditMode = false)
	{
		parent::DisplayBareRelations($oPage, $bEditMode);

		if(!$bEditMode)
		{
			$oPage->SetCurrentTab(Dict::S('UI:AutocloseTicket:Preview'));
			$this->OnShowPreview($oPage);
		}
	}


/**
	 * @param \WebPage $oPage
	 */
	public function OnShowPreview(WebPage $oPage)
	{
		$sClass = $this->Get('target_class');
		$sStimulusCode = $this->Get('stimulus_code');

		$oPage->p(MetaModel::GetClassIcon($sClass)."&nbsp;".Dict::Format('UI:AutocloseTicket:Title', MetaModel::GetName($sClass)));

		// Display a notice about the OQL being restricted when in advanced type
		if($this->Get('type') === 'advanced')
		{
			$aStatesCodes = $this->GetAvailableStatesForStimulus($sClass, $sStimulusCode);
			$aStates = array();
			foreach($aStatesCodes as $sStateCode)
			{
				$aStates[] = MetaModel::GetStateLabel($sClass, $sStateCode);
			}

			$sNoticeText = Dict::Format('UI:AutocloseTicket:AdvancedTypeStatesNotice', $sStimulusCode, implode(', ', $aStates));
			$oPage->add('<div class="header_message message_info">'.$sNoticeText.'</div>');
		}

		$aParams = array(
			'menu' => true,
			'table_id' => 'AutoCloseTicket_preview_rule_'.$this->GetKey(),
		);
		$oBlock = new DisplayBlock($this->GetFilter(), 'list', true, $aParams);
		$oBlock->Display($oPage, 'rel_preview_rule_'.$this->GetKey(), $aParams);
	}


	/**
	 * Note: This should be refactor into MetaModel but as this extension i supposed to be iTop 2.3 compatible we can't yet.
	 *
	 * @param string $sClass
	 * @param string $sStimulusCode
	 *
	 * @return array
	 */
	static public function GetAvailableStatesForStimulus($sClass, $sStimulusCode)
	{
		$aAvailableStatesCodes = array();
		foreach(MetaModel::EnumStates($sClass) as $sStateCode => $aState)
		{
			$aTransitions = MetaModel::EnumTransitions($sClass, $sStateCode);
			if (array_key_exists($sStimulusCode, $aTransitions))
			{
				$aAvailableStatesCodes[] = $sStateCode;
			}
		}

		return $aAvailableStatesCodes;
	}

}
//
// Menus
//
class MenuCreation_combodo_autoclose_ticket extends ModuleHandlerAPI
{
	public static function OnMenuCreation()
	{
		global $__comp_menus__; // ensure that the global variable is indeed global !
		$__comp_menus__['ServiceManagement'] = new MenuGroup('ServiceManagement', 60 , null, UR_ACTION_MODIFY, UR_ALLOWED_YES, null);
		$__comp_menus__['ClosingRule'] = new OQLMenuNode('ClosingRule', "SELECT ClosingRule", $__comp_menus__['ServiceManagement']->GetIndex(), 16, true , null, UR_ACTION_MODIFY, UR_ALLOWED_YES, null, true);
	}
} // class MenuCreation_combodo_autoclose_ticket
